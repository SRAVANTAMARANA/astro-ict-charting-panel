<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Astro ICT Chart Panel</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b2b4a; --panel:#fff; --muted:#666; --accent:#007bff;
    }
    body{margin:0;font-family:Inter,Roboto,Arial,sans-serif;background:#0f2a44;color:#111;}
    .app { display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box; }
    .left { flex:1; display:flex; flex-direction:column; gap:12px; }
    .right { width:360px; display:flex; flex-direction:column; gap:12px; }
    .panel { background:var(--panel); border-radius:8px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .controls input, .controls select, .controls button { padding:8px 10px; font-size:14px; border-radius:6px; border:1px solid #ddd; }
    #chart { height:560px; width:100%; }
    .small { font-size:13px; color:var(--muted); }
    .signals { max-height:360px; overflow:auto; }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .statusbar { position:fixed; left:12px; bottom:12px; background:#fff;padding:8px 10px;border-radius:6px; box-shadow:0 6px 20px rgba(0,0,0,0.15); }
    .hidden { display:none !important; }
    .tv-wrap { position:relative; height:0; overflow:hidden; transition:height .25s ease; }
    .tv-wrap.open { height:600px; }
    .signals-tray { position:relative; }
    .btn { background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:6px; padding:8px 10px; }
    .btn.secondary { background:#eee; color:#111; }
    .flex { display:flex; gap:8px; }
    .grow { flex:1; }
    .mini { padding:6px 8px; font-size:13px; }
    .muted { color:var(--muted); }
    pre { max-height:260px; overflow:auto; background:#f7f7f7; padding:10px; border-radius:6px; }
    .topline { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  </style>

  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
  <!-- TradingView widget library (will be loaded on demand when user opens TV) -->
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="panel topline">
        <div>
          <h2 style="margin:0">Astro ICT Chart Panel</h2>
          <div class="small">Local testing UI — connect backend on <code>http://localhost:8000</code></div>
        </div>

        <div class="toolbar">
          <button class="btn mini" id="fullscreenBtn">Fullscreen</button>
          <button class="btn mini secondary" id="toggleTheme">Theme</button>
        </div>
      </div>

      <!-- Controls -->
      <div class="panel controls">
        <label><input id="symbol" value="XAUUSD" /></label>
        <label>
          <select id="interval">
            <option value="1min">1m</option>
            <option value="5min" selected>5m</option>
            <option value="15min">15m</option>
            <option value="30min">30m</option>
            <option value="1h">1h</option>
            <option value="1d">1d</option>
          </select>
        </label>
        <label><input id="limit" type="number" value="150" style="width:90px" /></label>

        <div style="margin-left:auto;display:flex;gap:8px">
          <button id="loadBtn" class="btn">Load</button>
          <button id="tvBtn" class="btn secondary">TV</button>
          <button id="refreshHealth" class="btn secondary mini">Health</button>
        </div>
      </div>

      <!-- Chart container -->
      <div class="panel" id="chartPanel">
        <div id="chart" aria-label="chart area"></div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button class="btn secondary" id="btnZoomIn">Zoom In</button>
          <button class="btn secondary" id="btnZoomOut">Zoom Out</button>
          <button class="btn secondary" id="btnSavePNG">Export PNG</button>
          <div style="margin-left:auto" class="small">Status: <span id="status">idle</span></div>
        </div>
      </div>

      <!-- TV widget container (hidden until toggled) -->
      <div class="panel tv-wrap" id="tvWrap">
        <div id="tvContainer" style="height:100%;"></div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <h3 style="margin:0 0 8px 0">AI Mentor</h3>
        <div class="small">AI Mentor demo — lightweight control panel</div>
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="refreshMentor" class="btn">Refresh Mentor</button>
          <button id="speakMentor" class="btn secondary">Speak</button>
        </div>
        <pre id="mentorText">AI mentor demo text</pre>
      </div>

      <div class="panel signals-tray">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3 style="margin:0">Signals</h3>
          <div>
            <button id="showHideSignals" class="btn mini secondary">Show/Hide</button>
            <button id="refreshSignals" class="btn mini">Refresh</button>
          </div>
        </div>
        <div id="signals" class="signals muted">No signals yet</div>
      </div>

      <div class="panel">
        <h4 style="margin:0">Health & Debug</h4>
        <div style="margin-top:6px;">
          <button id="healthCheck" class="btn mini">Check Health</button>
          <button id="connectWS" class="btn mini secondary">Connect WS</button>
        </div>
        <pre id="debugConsole" style="margin-top:8px;">Console output...</pre>
      </div>
    </div>
  </div>

  <div class="statusbar panel" id="floatingStatus" role="status">
    <strong id="floatText">Status: idle</strong>
    <span id="latency" style="margin-left:10px;color:#555;font-size:13px"></span>
  </div>

<script>
/* =========================
   Configuration
   ========================= */
const API_BASE = "http://localhost:8000"; // backend base
const WS_BASE  = "ws://localhost:8000/ws"; // backend websocket (optional)

/* =========================
   Helpers & DOM refs
   ========================= */
const el = id => document.getElementById(id);
const status = (s) => { el('status').innerText = s; el('floatText').innerText = "Status: " + s; }
const debug = (s) => { const d = el('debugConsole'); d.innerText = (new Date()).toISOString() + " - " + s + "\n" + d.innerText; }

/* =========================
   Chart initialization
   ========================= */
let chart = null;
let candleSeries = null;
let currentTheme = 'light';

function initChart() {
  if(chart) return;
  const container = el('chart');
  chart = LightweightCharts.createChart(container, {
    width: container.clientWidth,
    height: 560,
    layout: {
      backgroundColor: currentTheme === 'dark' ? '#0b2b4a' : '#ffffff',
      textColor: currentTheme === 'dark' ? '#d9e6ff' : '#333',
    },
    grid: {
      vertLines: { color: currentTheme === 'dark' ? '#1f395a' : '#eee' },
      horzLines: { color: currentTheme === 'dark' ? '#1f395a' : '#eee' },
    },
    localization: { timeFormatter: (businessDayOrTimestamp) => {
      const d = new Date(businessDayOrTimestamp * 1000);
      return d.toISOString().replace('T',' ').substr(0,19);
    } }
  });
  candleSeries = chart.addCandlestickSeries();
  window.addEventListener('resize', () => {
    chart.applyOptions({ width: container.clientWidth });
  });
}

/* =========================
   Fetching candles
   ========================= */
async function loadCandles(symbol, interval, limit=200) {
  status("loading candles...");
  debug(`loadCandles(${symbol}, ${interval}, ${limit})`);
  try {
    const url = `${API_BASE}/ict/candles?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
    const r = await fetch(url);
    if (!r.ok) {
      const txt = await r.text();
      throw new Error("HTTP " + r.status + " - " + txt);
    }
    const data = await r.json();
    if(!data || !Array.isArray(data.candles)) {
      debug("Malformed candles response: " + JSON.stringify(data).slice(0,200));
      status("no candle data");
      return [];
    }
    const arr = data.candles.map(c => {
      // support either timestamp or ISO time
      const t = (typeof c.time === 'number') ? c.time : (new Date(c.time)).getTime() / 1000;
      return { time: Math.floor(t), open: +c.open, high: +c.high, low: +c.low, close: +c.close };
    });
    status("candles loaded");
    debug(`loaded ${arr.length} candles`);
    return arr;
  } catch (err) {
    console.error(err);
    debug("loadCandles error: " + err.message);
    status("candles failed");
    return [];
  }
}

/* =========================
   Render candles to chart
   ========================= */
async function render(symbol, interval, limit) {
  initChart();
  const data = await loadCandles(symbol, interval, limit);
  if(data.length === 0) {
    el('mentorText').innerText = "No candles returned.";
    return;
  }
  candleSeries.setData(data);
  status(`rendered ${data.length} candles`);
}

/* =========================
   Signals & Mentor
   ========================= */
async function fetchSignals() {
  try {
    const r = await fetch(`${API_BASE}/ict/signals`);
    if (!r.ok) throw new Error("HTTP " + r.status);
    const j = await r.json();
    const list = j.signals || [];
    const container = el('signals');
    if (list.length === 0) container.innerText = "No signals";
    else {
      container.innerHTML = list.map(s => `<div><strong>${s.type}</strong> ${s.desc || ''} <small class="muted">${s.time || ''}</small></div>`).join('');
    }
    debug("signals refreshed");
  } catch (err) {
    debug("fetchSignals error: " + err.message);
    el('signals').innerText = "Signals error";
  }
}

async function refreshMentor(){
  // demo placeholder - fetch from backend AI endpoint if exists
  try {
    const r = await fetch(`${API_BASE}/ict/mentor`); // optional
    if (r.ok) {
      const j = await r.json();
      el('mentorText').innerText = j.text || "AI mentor response";
    } else {
      el('mentorText').innerText = "AI mentor offline (demo)";
    }
  } catch(e){
    el('mentorText').innerText = "AI mentor demo text (no backend).";
  }
}

/* =========================
   Health & WebSocket
   ========================= */
async function checkHealth(){
  try {
    const r = await fetch(`${API_BASE}/ict/health`);
    if (!r.ok) throw new Error("HTTP " + r.status);
    const j = await r.json();
    status("backend: " + (j.status||"ok"));
    el('latency').innerText = ` ${j.time || ''}`;
    debug("Health OK");
  } catch (err) {
    status("backend down");
    debug("Health error: " + err.message);
  }
}

let ws = null;
function connectWS(){
  if (ws && ws.readyState === WebSocket.OPEN) {
    debug("WS already open");
    return;
  }
  try {
    ws = new WebSocket(WS_BASE);
    ws.addEventListener('open', () => {
      debug("WS open");
      status("ws open");
    });
    ws.addEventListener('message', (ev) => {
      debug("WS msg: " + ev.data);
      // attempt parse JSON and update chart/signals as needed
      try {
        const obj = JSON.parse(ev.data);
        if (obj.type === 'candles_update' && obj.candles) {
          const arr = obj.candles.map(c => ({ time: Math.floor(new Date(c.time).getTime()/1000), open:+c.open, high:+c.high, low:+c.low, close:+c.close }));
          candleSeries.update(arr[arr.length-1]);
          debug("WS updated series");
        } else if (obj.type === 'signal') {
          fetchSignals(); // refresh
        }
      } catch(e){}
    });
    ws.addEventListener('close', () => { debug("WS closed"); status("ws closed"); });
    ws.addEventListener('error', (e) => { debug("WS error"); });
  } catch (e) {
    debug("WS connect failed: " + e.message);
  }
}

/* =========================
   TradingView widget loader (on demand)
   ========================= */
let tvLoaded = false;
async function loadTradingViewWidget(){
  if(tvLoaded) return;
  // load script
  await new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = "https://s3.tradingview.com/tv.js";
    s.onload = () => { tvLoaded = true; res(); };
    s.onerror = () => rej(new Error("TradingView script load failed"));
    document.head.appendChild(s);
  });

  // create widget
  const container = el('tvContainer');
  container.innerHTML = '';
  new TradingView.widget({
    "container_id": "tvContainer",
    "width": "100%",
    "height": "600",
    "symbol": el('symbol').value || "XAUUSD",
    "interval": "60",
    "timezone": "Etc/UTC",
    "theme": "Light",
    "style": "1",
    "locale": "en",
    "toolbar_bg": "#f1f3f6",
    "enable_publishing": false,
    "hideideas": true
  });
}

/* =========================
   UI hooks
   ========================= */
el('loadBtn').addEventListener('click', async () => {
  const sym = el('symbol').value || 'XAUUSD';
  const intv = el('interval').value || '1min';
  const lim = parseInt(el('limit').value) || 150;
  await render(sym, intv, lim);
});

el('refreshSignals').addEventListener('click', fetchSignals);
el('showHideSignals').addEventListener('click', () => {
  const s = el('signals');
  s.classList.toggle('hidden');
});
el('refreshMentor').addEventListener('click', refreshMentor);

el('healthCheck').addEventListener('click', checkHealth);
el('connectWS').addEventListener('click', connectWS);

el('tvBtn').addEventListener('click', async () => {
  const w = el('tvWrap');
  const open = w.classList.toggle('open');
  if (open) {
    try { await loadTradingViewWidget(); } catch(e){ debug("TV load failed: " + e.message); }
  }
});

el('fullscreenBtn').addEventListener('click', () => {
  const elRoot = document.documentElement;
  if (!document.fullscreenElement) {
    elRoot.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
});

el('toggleTheme').addEventListener('click', () => {
  currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
  // destroy and re-init with new theme
  if (chart) { chart.remove(); chart = null; candleSeries = null; }
  initChart();
});

el('btnZoomIn').addEventListener('click', () => { chart.timeScale().zoomIn(); });
el('btnZoomOut').addEventListener('click', () => { chart.timeScale().zoomOut(); });
el('btnSavePNG').addEventListener('click', () => {
  // Lightweight charts can export as image using canvas -> not available in standalone build easily
  debug("Export not implemented client-side (use server-side capture if needed)");
});

/* =========================
   Startup sequence
   ========================= */
(async function start() {
  initChart();
  checkHealth();
  // try auto-load small sample
  const defaultSym = el('symbol').value || 'XAUUSD';
  const candles = await loadCandles(defaultSym, el('interval').value, +el('limit').value);
  if (candles.length) candleSeries.setData(candles);
  fetchSignals();
  refreshMentor();

  // helpful curl test (visual debugging)
  try {
    const c = await fetch(`${API_BASE}/ict/candles?symbol=${defaultSym}&interval=1min&limit=10`);
    debug("Sample endpoint status: " + c.status);
  } catch(e){
    debug("Sample endpoint fetch failed: " + e.message);
  }
})();

</script>
</body>
</html>
