<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Astro ICT Chart Panel - standalone test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; }
    #root { display:flex; height:100%; gap:12px; padding:12px; box-sizing:border-box; background:#f8fafc; }
    #left { width:72%; min-width:480px; background:#fff; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.06); display:flex; flex-direction:column; }
    #chart { flex:1; min-height:360px; }
    #controls { padding:8px 12px; display:flex; gap:8px; align-items:center; border-top:1px solid #eef2f7; }
    .btn { padding:8px 12px; border-radius:6px; border:1px solid #cbd5e1; background:#fff; cursor:pointer; }
    #right { width:28%; min-width:240px; background:#fff; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.06); padding:12px; box-sizing:border-box; }
    .muted { color:#6b7280; font-size:13px; }
    pre { background:#0b1220; color:#dbeafe; padding:8px; border-radius:6px; overflow:auto; max-height:240px; }
    .error { color: #ff5555; }
  </style>
</head>
<body>
  <!-- 1) Use a specific version of lightweight-charts that we know works -->
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

  <div id="root">
    <div id="left">
      <div id="chart"></div>
      <div id="controls">
        <select id="symbol" class="btn">
          <option value="XAUUSD">XAUUSD</option>
          <option value="BTCUSDT">BTCUSDT</option>
          <option value="EURUSD">EURUSD</option>
        </select>
        <select id="interval" class="btn">
          <option value="1min">1m</option>
          <option value="5min" selected>5m</option>
          <option value="1h">1h</option>
          <option value="1d">1d</option>
        </select>
        <button id="loadBtn" class="btn">Load</button>
        <button id="tvBtn" class="btn">Open TV</button>
        <span id="status" class="muted">status: idle</span>
      </div>
    </div>

    <div id="right">
      <div class="muted">Signals / Logs</div>
      <pre id="log">ready.</pre>
    </div>
  </div>

  <!-- 2) our inline app - uses global factory (no import) -->
  <script>
  (function () {
    // --- helpers / config ---
    const chartDiv = document.getElementById('chart');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const symbolSel = document.getElementById('symbol');
    const intervalSel = document.getElementById('interval');
    const loadBtn = document.getElementById('loadBtn');
    const tvBtn = document.getElementById('tvBtn');

    function log(msg, isError = false) { 
      logEl.textContent += '\n' + msg; 
      logEl.scrollTop = 1e9;
      if (isError) {
        logEl.classList.add('error');
      }
    }
    function setStatus(s) { statusEl.textContent = 'status: ' + s; }

    // --- chart state ---
    let chart = null;
    let candleSeries = null;

    // create or recreate chart
    function createOrRecreateChart(themeDark = false) {
      try {
        if (chart) {
          // remove old chart
          try { chart.remove(); } catch(e) { log('Error removing chart: ' + e.message, true); }
          chart = null;
          candleSeries = null;
        }

        const layout = {
          background: { color: themeDark ? '#0b1220' : '#ffffff' },
          textColor: themeDark ? '#dbeafe' : '#333',
          fontSize: 12,
          fontFamily: "Arial"
        };

        // Create chart using the correct API
        chart = LightweightCharts.createChart(chartDiv, {
          width: chartDiv.clientWidth,
          height: chartDiv.clientHeight,
          layout,
          rightPriceScale: { borderVisible: false },
          timeScale: { borderVisible: false },
        });

        // Check if chart was created successfully
        if (!chart || typeof chart.addCandlestickSeries !== 'function') {
          throw new Error('Chart object is invalid or does not have addCandlestickSeries method');
        }

        // add candlestick series via API on the created chart object
        candleSeries = chart.addCandlestickSeries({
          upColor: '#26a69a',
          downColor: '#ef5350',
          wickColor: '#737375',
          borderVisible: true
        });

        if (!candleSeries) {
          throw new Error('Failed to create candlestick series');
        }

        chart.timeScale().subscribeVisibleTimeRangeChange(range => {
          // called when user changes zoom/scroll; you can update stats here
          // console.log('visible range changed', range);
        });

        setStatus('chart created');
        log('Chart created successfully');
      } catch (err) {
        setStatus('error creating chart');
        log('createChart error: ' + (err && err.message ? err.message : String(err)), true);
        console.error(err);
      }
    }

    // resize handler
    window.addEventListener('resize', () => {
      if (!chart) return;
      chart.applyOptions({ width: chartDiv.clientWidth, height: chartDiv.clientHeight });
    });

    // fetch candles from backend
    async function fetchCandles(symbol, interval, limit = 200) {
      // Replace this path with your backend endpoint if different
      const url = `/ict/candles?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
      setStatus('fetching ' + symbol + ' ' + interval);
      try {
        const resp = await fetch(url, { cache: 'no-store' });
        if (!resp.ok) throw new Error('HTTP ' + resp.status + ' ' + resp.statusText);
        const data = await resp.json();
        // expect data.candles or data array. Accept both shapes:
        if (Array.isArray(data)) return data;
        if (Array.isArray(data.candles)) return data.candles;
        // if server response wrapper different, attempt to extract
        return data;
      } catch (err) {
        log('fetch error: ' + err.message, true);
        throw err;
      }
    }

    // minimal fallback sample candles if backend not available
    function sampleCandles() {
      return [
        {time: '2025-09-23T15:35:00Z', open: 1930, high:1935, low:1927, close:1932, volume:10},
        {time: '2025-09-23T15:40:00Z', open: 1932, high:1936, low:1930, close:1934, volume:8},
        {time: '2025-09-23T15:45:00Z', open: 1934, high:1938, low:1931, close:1936, volume:12},
        {time: '2025-09-23T15:50:00Z', open: 1936, high:1940, low:1934, close:1939, volume:15},
      ];
    }

    // normalize server candle objects to lightweight-charts input:
    // time should be either unix seconds (number) or ISO string 'YYYY-MM-DDTHH:mm:ssZ'
    function normalizeCandles(raw) {
      if (!Array.isArray(raw)) return [];
      return raw.map(c => {
        // accept both {t,open,high,low,close,volume} or {time,open,high...} or {dt, o,h,l,c}
        const time = c.time || c.t || c.dt || c.timestamp || c.date || null;
        // if numeric timestamp (ms) convert to ISO seconds string:
        if (typeof time === 'number') {
          // assume ms -> convert to seconds (UNIX) or to ISO string accepted by library
          const maybeMs = time > 1e12; // ms
          if (maybeMs) {
            return { time: new Date(time).toISOString(), open: +c.open, high:+c.high, low:+c.low, close:+c.close, volume: c.volume||0 };
          } else {
            // seconds
            return { time: time, open:+c.open, high:+c.high, low:+c.low, close:+c.close, volume: c.volume||0 };
          }
        } else if (typeof time === 'string') {
          // if it's already an ISO or date-like string, pass through
          return { time: time, open:+c.open, high:+c.high, low:+c.low, close:+c.close, volume: c.volume||0 };
        } else {
          // fallback: use index time -> not ideal
          return { time: new Date().toISOString(), open:+c.open, high:+c.high, low:+c.low, close:+c.close, volume: c.volume||0 };
        }
      });
    }

    async function loadAndRender() {
      if (!candleSeries) {
        log('Error: Candlestick series not initialized', true);
        return;
      }

      const symbol = symbolSel.value || 'XAUUSD';
      const interval = intervalSel.value || '5min';
      try {
        setStatus('loading ' + symbol);
        log('loading ' + symbol + ' / ' + interval);
        let raw;
        try {
          raw = await fetchCandles(symbol, interval, 500);
          log('fetched ' + (Array.isArray(raw) ? raw.length : JSON.stringify(Object.keys(raw))));
        } catch (err) {
          log('fetch failed - using sample data');
          raw = sampleCandles();
        }

        const data = normalizeCandles(raw);
        if (!data || data.length === 0) {
          log('no candle data found; using sample');
          candleSeries.setData(sampleCandles());
          setStatus('rendered (sample)');
          return;
        }

        candleSeries.setData(data);
        chart.timeScale().fitContent();
        setStatus('rendered ' + symbol);
      } catch (err) {
        setStatus('render error');
        log('render error: ' + (err && err.message ? err.message : String(err)), true);
        console.error(err);
      }
    }

    // open tradingview website (lightweight button)
    tvBtn.addEventListener('click', () => {
      window.open('https://www.tradingview.com/chart/', '_blank');
    });

    // attach load button
    loadBtn.addEventListener('click', loadAndRender);

    // Initialize the app when the library is loaded
    function initializeApp() {
      // Check if the library is loaded
      if (typeof LightweightCharts !== 'undefined' && 
          typeof LightweightCharts.createChart === 'function') {
        
        log('LightweightCharts library loaded successfully');
        
        // create chart initially
        createOrRecreateChart(false);

        // initial load of default symbol
        loadAndRender();
        
        // expose a global for debugging if needed
        window.__ICT_CHART = { chart, candleSeries, createOrRecreateChart, loadAndRender };
      } else {
        // If not loaded yet, wait and try again
        log('Waiting for LightweightCharts library to load...');
        setTimeout(initializeApp, 100);
      }
    }

    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
  })();
  </script>
</body>
</html>
